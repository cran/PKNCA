<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>    toc_depth: 2</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{Introduction to PKNCA and Usage Instructions}
-->

<hr/>

<p>title: &ldquo;Introduction to PKNCA and Usage Instructions&rdquo;
author: &ldquo;Bill Denney&rdquo;
output:
  html_document:
    toc: true</p>

<h2>    toc_depth: 2</h2>

<p>PKNCA provides functions to complete noncompartmental analysis (NCA)
for pharmacokinetic (PK) data.  Its intent is to provide a complete
R-based solution enabling data provenance for NCA including tracking
data cleaning, enabling calculations, exporting results, and
reporting.  The library is designed to give a reasonable answer
without user intervention (load, calculate, and summarize), but it
allows the user to override the automatic selections at any point.</p>

<p>The library design is modular to allow expansion based on needs
unforseen by the authors including new NCA parameters, novel data
cleaning methods, and modular summarization decisions.  Expanding the
library will be discussed in a separate vignette.</p>

<h1>Quick Start</h1>

<p>The simplest analysis requires concentration and dosing data, then
five function calls can provide summarized results.  (Please note that this and the other examples in this document are intended to show the typical workflow, but they are not intended to run directly.  For an example to run directly, please see <a href="Example-theophylline.html">the theophylline example</a>.)</p>

<pre><code class="r">library(PKNCA)

## Load the PK concentration data
d.conc &lt;- read.csv(&quot;concentration.csv&quot;, stringsAsFactors=FALSE)
## Load the dosing data
d.dose &lt;- read.csv(&quot;dose.csv&quot;, stringsAsFactors=FALSE)

## Create a concentration object specifying the concentration, time,
## study, and subject columns.  (Note that any number of grouping
## levels is supporting; you are not restricted to this list.)
my.conc &lt;- PKNCAconc(d.conc,
                     concentration~time|study+subject)
## Create a dosing object specifying the dose, time, study, and
## subject columns.  (Note that the grouping factors should be a
## subset of the grouping factors for concentration, and the columns
## must have the same names between concentration and dose objects.)
my.dose &lt;- PKNCAdose(d.dose,
                     dose~time|study+subject)
## Combine the concentration and dosing information both to
## automatically define the intervals for NCA calculation and provide
## doses for calculations requiring dose.
my.data &lt;- PKNCAdata(my.conc, my.dose)

## Calculate the NCA parameters
my.results &lt;- pk.nca(my.data)

## Summarize the results
summary(my.results)
</code></pre>

<h1>Data Handling</h1>

<p>After loading data, it must be in the right form.  The minimum
requirements are that concentration, dose, and time must all be
numeric (and not factors).  Grouping variables have no specific
requirements; they can be any mode.</p>

<p>Values below the limit of quantificaiton are coded as zeros (<code>{r
eval=FALSE}0</code>), and missing values are coded as <code>{r eval=FALSE}NA</code>.</p>

<h1>Options: Make PKNCA Work Your Way</h1>

<h2>Calculation Options: the PKNCA.options Function</h2>

<p>Different organizations have different requirements for computation
and summarization of NCA.  Options for how to perform calculations and
summaries are handled by the <code>{r eval=FALSE}PKNCA.options</code> command.</p>

<p>Default options have been set to commonly-used standard parameters.
The current value for options can be found by running the command with
no arguments:</p>

<pre><code class="r">PKNCA.options()
</code></pre>

<pre><code>## $adj.r.squared.factor
## [1] 1e-04
## 
## $max.missing
## [1] 0.5
## 
## $auc.method
## [1] &quot;lin up/log down&quot;
## 
## $conc.na
## [1] &quot;drop&quot;
## 
## $conc.blq
## $conc.blq$first
## [1] &quot;keep&quot;
## 
## $conc.blq$middle
## [1] &quot;drop&quot;
## 
## $conc.blq$last
## [1] &quot;keep&quot;
## 
## 
## $first.tmax
## [1] TRUE
## 
## $allow.tmax.in.half.life
## [1] FALSE
## 
## $min.hl.points
## [1] 3
## 
## $min.span.ratio
## [1] 2
## 
## $max.aucinf.pext
## [1] 20
## 
## $min.hl.r.squared
## [1] 0.9
## 
## $tau.choices
## [1] NA
## 
## $single.dose.aucs
##   start end auclast aucall aumclast aumcall  cmax  cmin  tmax tlast tfirst
## 1     0  24    TRUE  FALSE    FALSE   FALSE FALSE FALSE FALSE FALSE  FALSE
## 2     0 Inf   FALSE  FALSE    FALSE   FALSE  TRUE FALSE  TRUE FALSE  FALSE
##   clast.obs     f   mrt mrt.last   cav ctrough   ptr  tlag half.life
## 1     FALSE FALSE FALSE    FALSE FALSE   FALSE FALSE FALSE     FALSE
## 2     FALSE FALSE FALSE    FALSE FALSE   FALSE FALSE FALSE      TRUE
##   r.squared adj.r.squared lambda.z lambda.z.time.first lambda.z.n.points
## 1     FALSE         FALSE    FALSE               FALSE             FALSE
## 2     FALSE         FALSE    FALSE               FALSE             FALSE
##   clast.pred span.ratio thalf.eff   kel aucinf aumcinf aucpext    cl    vz
## 1      FALSE      FALSE     FALSE FALSE  FALSE   FALSE   FALSE FALSE FALSE
## 2      FALSE      FALSE     FALSE FALSE   TRUE   FALSE   FALSE FALSE FALSE
##     vss    vd
## 1 FALSE FALSE
## 2 FALSE FALSE
</code></pre>

<p>And, to reset the current values to the library defaults, run the
function with the default argument set to <code>TRUE</code>.</p>

<pre><code class="r">PKNCA.options(default=TRUE)
</code></pre>

<p>Each of the options is documented where it is used; for example, the
first.tmax option is documented in the <code>{r eval=FALSE}pk.calc.tmax</code>
function.</p>

<h2>Summarization Options: the PKNCA.set.summary Function</h2>

<p>On top of methods of calculation, summarization method preferences
differ.  Typical summarization preferences include selection of the
measurement of central tendency and dispersion, handling of missing
values, handling of values below the limit of quantification, and
more.  Beyond the method for summarization, presentation is managed
through user preferences.  Presentation is typically controlled by
rounding to either a defined number of decimal places or significant
figures.</p>

<p>An example is that C~max~ may be summarized by the geometric mean with
the geometric CV using three significant figures, and having a summary
result requires that at least half of the available values are present
(not missing).  The code below will set this example.</p>

<pre><code class="r">PKNCA.set.summary(name=&quot;cmax&quot;,
                  point=business.geomean,
                  spread=business.geocv,
                  rounding=list(signif=3))
</code></pre>

<p>Another example is that T~max~ is usually summarized by the median and
range, and as measurements are often taken with minute resolution and
recorded in hours, reporting is usually to the second decimal place.</p>

<pre><code class="r">PKNCA.set.summary(name=&quot;tmax&quot;,
                  point=business.median,
                  spread=business.range,
                  rounding=list(round=2))
</code></pre>

<p>If the functions or default rounding options provided in the library
do not meet the summarization needs, a user-supplied function can be
used for rounding.</p>

<h1>Grouping NCA Data</h1>

<p>As described in the <a href="#quick-start">quick start</a>, concentration and dose
data are generally grouped to identify how to separate the data.
Typical groups for concentration data include study, treatment,
subject, and analyte.  Typical groups for dose data include study,
treatment, and subject.  By default, summaries are produced based on
the concentration groups dropping the subject (so that averages are
taken across subjects within the other parameters).</p>

<p>The quick start example can be extended to include multiple analytes
as follows.  The only difference is the <code>{r eval=FALSE}/analyte</code>
formula element in the concentration data.  The reason for the slash
instead of the plus is that the last element before a slash is assumed
to be the subject, and as noted before, the subject is (by default)
excluded from the summary grouping (so that summaries are grouped by
study, treatment, etc., but not by subject).</p>

<pre><code class="r">## Create a concentration object specifying the concentration, time,
## study, and subject columns.  (Note that any number of grouping
## levels is supporting; you are not restricted to this list.)
my.conc &lt;- PKNCAconc(d.conc,
                     concentration~time|study+subject/analyte)
## Create a dosing object specifying the dose, time, study, and
## subject columns.  (Note that the grouping factors should be a
## subset of the grouping factors for concentration, and the columns
## must have the same names between concentration and dose objects.)
my.dose &lt;- PKNCAdose(d.dose,
                     dose~time|study+subject)
</code></pre>

<h1>Selecting Calculation Intervals</h1>

<p>All NCA calculations require the inverval over which they are
calculated.  When the concentration and dosing information are
combined to the PKNCAdata object, intervals are automatically
determined.  The exception to this automatic determination is if the
user provides intervals.</p>

<p>When selected either automatically or manually, intervals define at
minimum a start time, an end time, and the parameters to be
calculated.  The parameter list is available from the <code>{r
eval=FALSE}get.interval.cols</code> function.  The parameters requested are
specified by setting the entry in a data.frame as requested.</p>

<pre><code class="r">intervals &lt;-
  data.frame(start=0, end=c(24, Inf),
             cmax=c(FALSE, TRUE),
             tmax=c(FALSE, TRUE),
             auclast=TRUE,
             aucinf=c(FALSE, TRUE))
</code></pre>

<p>Intervals like the above is sufficient for designs with
a single type of treatment&ndash; like single doses.  For more complex
treatments in a single analysis, like the combination of single and multiple doses,
include a treatment column matching
the treatment column name from the concentration data set.  See the <a href="manual-interval-specification">Manual Interval Specification</a> section below for more details.</p>

<h2>Automatic Interval Determination</h2>

<p>If intervals are not specified when combining the concentration and dosing data, they will automatically be found from the concentration and dosing data.</p>

<p>Single dose data has a simple interval selection:  the option <code>single.dose.aucs</code> is used from the <code>PKNCA.options</code>.</p>

<table><thead>
<tr>
<th align="right">start</th>
<th align="right">end</th>
<th align="left">auclast</th>
<th align="left">aucall</th>
<th align="left">aumclast</th>
<th align="left">aumcall</th>
<th align="left">cmax</th>
<th align="left">cmin</th>
<th align="left">tmax</th>
<th align="left">tlast</th>
<th align="left">tfirst</th>
<th align="left">clast.obs</th>
<th align="left">f</th>
<th align="left">mrt</th>
<th align="left">mrt.last</th>
<th align="left">cav</th>
<th align="left">ctrough</th>
<th align="left">ptr</th>
<th align="left">tlag</th>
<th align="left">half.life</th>
<th align="left">r.squared</th>
<th align="left">adj.r.squared</th>
<th align="left">lambda.z</th>
<th align="left">lambda.z.time.first</th>
<th align="left">lambda.z.n.points</th>
<th align="left">clast.pred</th>
<th align="left">span.ratio</th>
<th align="left">thalf.eff</th>
<th align="left">kel</th>
<th align="left">aucinf</th>
<th align="left">aumcinf</th>
<th align="left">aucpext</th>
<th align="left">cl</th>
<th align="left">vz</th>
<th align="left">vss</th>
<th align="left">vd</th>
</tr>
</thead><tbody>
<tr>
<td align="right">0</td>
<td align="right">24</td>
<td align="left">TRUE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
</tr>
<tr>
<td align="right">0</td>
<td align="right">Inf</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">TRUE</td>
<td align="left">FALSE</td>
<td align="left">TRUE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">TRUE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">TRUE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
</tr>
</tbody></table>

<p>For multiple-dose studies, PKNCA selects one group at a time and compares the concentration and dosing times.  When there is a concentation measurement between doses, an interval row is added.  The dosing interval (\(\tau\)) is determined by looking for pattern repeats within the dosing data using the <code>find.tau</code> function.</p>

<pre><code class="r">## find.tau can work when all doses have the same interval...
dose.times &lt;- seq(0, 168, by=24)
print(dose.times)
</code></pre>

<pre><code>## [1]   0  24  48  72  96 120 144 168
</code></pre>

<pre><code class="r">PKNCA::find.tau(dose.times)
</code></pre>

<pre><code>## [1] 24
</code></pre>

<pre><code class="r">## or when the doses have mixed intervals (10 and 24 hours).
dose.times &lt;- sort(c(seq(0, 168, by=24),
                     seq(10, 178, by=24)))
print(dose.times)
</code></pre>

<pre><code>##  [1]   0  10  24  34  48  58  72  82  96 106 120 130 144 154 168 178
</code></pre>

<pre><code class="r">PKNCA::find.tau(dose.times)
</code></pre>

<pre><code>## [1] 24
</code></pre>

<p>After finding \(\tau\), PKNCA will also look after the last dose (or the beginning of the last dosing interval), and two additional intervals may be added:</p>

<ul>
<li>one interval for the dosing interval after the beginning of the last dosing interval (if there are concentrations measured in the interval)</li>
<li>one interval for the half-life after the last dosing interval (if there are concentration more than \(\tau\) after the beginning of the last interval).</li>
</ul>

<p>One consequence of automatic interval selection is that many rows are generated for intervals; one row is generated per interval per subject.  The benefit of the method producing a large number of rows is that it is fully flexible to the actual study results.  If a subject has a different schedule than the others for the same treatment (e.g. measurements that were nominally scheduled for day 14 occurred on day 13), those differences will be found.</p>

<h2>Manual Interval Specification</h2>

<p>Intervals can also be specified manually.  Two use cases are common for manual specification:  fully manual (never requesting the automatic intervals) and updating the automatic intervals.</p>

<p>Fully manual intervals can be specified by providing it to the <code>PKNCAdata</code> call.</p>

<pre><code class="r">my.intervals &lt;-
  data.frame(start=0, end=c(24, Inf),
             cmax=c(FALSE, TRUE),
             tmax=c(FALSE, TRUE),
             auclast=TRUE,
             aucinf=c(FALSE, TRUE))
my.data &lt;- PKNCAdata(my.conc, my.dose, 
                     intervals=my.intervals)
</code></pre>

<p>To update the automatically-selected intervals, extract the intervals, modify them, and put them back.</p>

<pre><code class="r">my.data &lt;- PKNCAdata(my.conc, my.dose)
my.intervals &lt;- my.data$intervals
my.intervals$aucinf[1] &lt;- TRUE
mydata$intervals &lt;- my.intervals
</code></pre>

</body>

</html>
